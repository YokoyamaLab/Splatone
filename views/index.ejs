<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <title>
    <%= title %>
  </title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
  <!-- Leaflet.draw CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" crossorigin="anonymous" />
  <link rel="stylesheet" href="style.css" />
  <!-- Toastify -->
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
</head>

<body>
  <!-- ハンバーガー -->
  <button id="hamburger" class="hamburger" aria-label="Open controls" aria-expanded="false" aria-controls="sidepanel">
    ☰
  </button>

  <!-- スライドオーバー（右） -->
  <aside id="sidepanel" class="sidepanel" aria-hidden="true">
    <header class="panel-header">
      <h2>Controls</h2>
      <button id="panelClose" class="icon-btn" aria-label="Close controls">✕</button>
    </header>

    <div class="panel-body">
      <section class="panel-section">
        <% if (browseMode) { %>
        <p class="muted">browseモードでは地図の閲覧のみ可能です。範囲描画とクロール開始は無効化されています。</p>
        <% } else { %>
        <p class="muted">
          地図上で <strong>矩形をドラッグ</strong> して BBOX を指定してください。<br>
          クリックした三角形と、<em>共有辺を持つ別Hexの三角形</em>が同時にハイライトされます。
        </p>
        <% } %>
      </section>

      <section class="panel-section">
        <label class="field">
          <span>Keywords</span>
          <input id="keywords" type="text" value="<%= defaultKeywords %>" />
        </label>
        <label class="field">
          <span>cellSize</span>
          <input id="cellSize" type="number" step="0.1" min="0.05" value="<%= defaultCellSize %>" />
        </label>

        <label class="field">
          <span>units</span>
          <select id="units">
            <option value="kilometers" <%=defaultUnits==='kilometers' ?'selected':'' %>>kilometers</option>
            <option value="meters" <%=defaultUnits==='meters' ?'selected':'' %>>meters</option>
            <option value="miles" <%=defaultUnits==='miles' ?'selected':'' %>>miles</option>
          </select>
        </label>

        <div class="bbox-row">
          <span id="bboxLabel" class="bbox-label"></span>
        </div>
      </section>

      <section class="panel-section">
        <label class="field">
          <span>CLI Command</span>
          <textarea id="cliCommand" class="cli-command" rows="4" readonly spellcheck="false"></textarea>
        </label>
        <div class="copy-row">
          <button id="copyCliCommand" class="btn" type="button">Copy to clipboard</button>
        </div>
      </section>

      <section class="panel-section" id="statsSection" hidden>
        <h3>統計情報</h3>
        <div id="statsSummary" class="stats-summary muted"></div>
        <div id="statsHexList" class="stats-hex-list"></div>
      </section>

      <section class="panel-section">
        <details>
          <summary>ヘルプ</summary>
          <ul class="muted">
            <li>左上の四角いツールで矩形を描画します。</li>
            <li>矩形を編集すると自動で再生成します。</li>
            <li>三角形をクリックすると、隣接する他Hexの三角形を同時ハイライト。</li>
          </ul>
        </details>
      </section>

      <section class="panel-section" id="rawReviewSection" hidden>
        <h3>Visualizer オプション</h3>
        <div class="muted" id="rawReviewHint">結果を読み込むとオプションを編集できます。</div>
        <div id="visOptionForms"></div>
        <div class="raw-actions">
          <button id="applyVisOptions" class="btn" type="button" disabled>再可視化</button>
          <button id="resetVisOptions" class="btn" type="button" disabled>リセット</button>
        </div>
        <div class="raw-meta" id="rawMetaInfo"></div>
      </section>
    </div>
  </aside>

  <!-- パネルの背面オーバーレイ -->
  <div id="panelOverlay" class="panel-overlay" hidden></div>

  <% if (browseMode) { %>
  <div id="dropOverlay" class="drop-overlay" hidden>
    <div class="drop-overlay__inner">
      <p class="drop-overlay__title">結果ファイルをドロップ</p>
      <p class="drop-overlay__subtitle">crawlerのresult*.jsonやエクスポートJSONを読み込めます</p>
    </div>
  </div>
  <% } %>

  <!-- 地図 -->
  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
  <!-- Leaflet.draw JS -->
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js" crossorigin="anonymous"></script>
  <!-- Map to Image -->
  <script src="https://cdn.jsdelivr.net/npm/leaflet-easyprint@2.1.9/dist/bundle.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/leaflet-easyprint@2.1.9/libs/leaflet.min.css" rel="stylesheet">
  <!-- Toastify -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
  <!-- Socket.IO JS -->
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <!-- Visualize.js -->
  <script src="visualizer.js"></script>
  <!-- Main JS -->
  <script type="module">
    const lat = <%= lat %>;
    const lon = <%= lon %>;
    const defaultGeometry = <%- JSON.stringify(defaultGeometry || {}) %>;
    const browseMode = <%- JSON.stringify(Boolean(browseMode)) %>;
    const cliContext = {
      baseCommand: <%- JSON.stringify(cliBaseCommand || '') %>,
      provider: <%- JSON.stringify(selectedProvider || '') %>,
      visualizers: <%- JSON.stringify(selectedVisualizers || []) %>,
    };
    const socket = io({
      path: "/socket",
      reconnection: false
    });

    const VIS_FORM_STATE = {
      defaultOptions: {},
      currentOptions: {},
      rawSource: null,
      visualizerOrder: []
    };

    function debounce(fn, wait = 300) {
      let timer = null;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn(...args), wait);
      };
    }

    function readMapViewCookie() {
      const entry = document.cookie.split('; ').find(row => row.startsWith('splatoneMapView='));
      if (!entry) return null;
      try {
        const encoded = entry.split('=')[1];
        return JSON.parse(decodeURIComponent(encoded));
      } catch {
        return null;
      }
    }

    function writeMapViewCookie({ lat, lon, zoom }) {
      const payload = encodeURIComponent(JSON.stringify({ lat, lon, zoom }));
      const maxAge = 60 * 60 * 24 * 30; // 30 days
      document.cookie = `splatoneMapView=${payload}; path=/; max-age=${maxAge}`;
    }

    const storedView = readMapViewCookie();
    const initialLat = Number.isFinite(Number(storedView?.lat)) ? Number(storedView.lat) : lat;
    const initialLon = Number.isFinite(Number(storedView?.lon)) ? Number(storedView.lon) : lon;
    const initialZoom = Number.isFinite(Number(storedView?.zoom)) ? Number(storedView.zoom) : 12;

    function setProgress(el, value) {
      //プログレスバー
      const v = Math.max(0, Math.min(100, Number(value)));
      el.style.setProperty('--value', v);
      el.setAttribute('aria-valuenow', String(v));
      const label = el.querySelector('.progress__label');
      if (label) label.textContent = v + '%';
    }

    function formatPercentValue(value) {
      if (!Number.isFinite(value)) return '0%';
      return (Math.round(Math.max(0, Math.min(1, value)) * 1000) / 10) + '%';
    }

    function renderStatsPanel(stats) {
      const section = document.getElementById('statsSection');
      const summaryEl = document.getElementById('statsSummary');
      const hexListEl = document.getElementById('statsHexList');
      if (!section || !summaryEl || !hexListEl) return;
      if (!stats || !stats.totals) {
        section.hidden = true;
        summaryEl.textContent = '';
        hexListEl.textContent = '';
        return;
      }
      const totals = stats.totals;
      section.hidden = false;
      summaryEl.innerHTML = `
        <div>Hex総数: <strong>${totals.hexes ?? 0}</strong></div>
        <div>カテゴリ数: <strong>${totals.categories ?? 0}</strong></div>
        <div>取得済み: <strong>${totals.crawled ?? 0}</strong></div>
        <div>残り推定: <strong>${totals.remaining ?? 0}</strong></div>
        <div>進捗: <strong>${formatPercentValue(totals.percent ?? 0)}</strong></div>
      `;

      const entries = Object.entries(stats.hexes ?? {});
      if (!entries.length) {
        hexListEl.innerHTML = '<p class="muted">Hex単位の統計はまだありません。</p>';
        return;
      }
      entries.sort((a, b) => (b[1]?.percent ?? 0) - (a[1]?.percent ?? 0));
      const rows = entries.slice(0, 6).map(([hexId, info]) => {
        const percent = formatPercentValue(info?.percent ?? 0);
        const crawled = info?.crawled ?? 0;
        const expected = info?.expected ?? info?.total ?? (crawled + (info?.remaining ?? 0));
        const remaining = info?.remaining ?? Math.max(0, expected - crawled);
        return `
          <div class="stats-hex-row">
            <span class="stats-hex-label">Hex ${hexId}</span>
            <span class="stats-hex-progress">${percent}</span>
            <span class="stats-hex-detail">${crawled}/${expected} (残り${remaining})</span>
          </div>
        `;
      });
      hexListEl.innerHTML = rows.join('');
    }

    function downloadJSON(filename, obj) {
      const json = JSON.stringify(obj, null, 2);
      const blob = new Blob([json], {
        type: "application/json"
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

  let currentDrawnGeoJSON = null;
  let currentDrawKind = null;
  let currentBboxArray = null;

  const cliTextarea = document.getElementById('cliCommand');
  const copyCliButton = document.getElementById('copyCliCommand');

    function quoteSingle(value) {
      const safe = String(value ?? '').replace(/'/g, "''");
      return "'" + safe + "'";
    }

    function buildCliCommandString() {
      if (!cliContext?.baseCommand) return '';
      const parts = [cliContext.baseCommand.trim()].filter(Boolean);
      if (cliContext.provider) {
        parts.push('-p', cliContext.provider);
      }
      if (Array.isArray(cliContext.visualizers)) {
        cliContext.visualizers.forEach((vis) => {
          if (vis) parts.push(`--vis-${vis}`);
        });
      }
      const visOptionArgs = buildVisualizerOptionArgs();
      if (visOptionArgs.length) {
        parts.push(...visOptionArgs);
      }
      const keywordsInput = document.getElementById('keywords');
      const keywordsVal = keywordsInput?.value?.trim();
      if (keywordsVal) {
        parts.push('-k', quoteSingle(keywordsVal));
      }
      const cellSizeInput = document.getElementById('cellSize');
      const cellSizeVal = cellSizeInput?.value?.trim();
      if (cellSizeVal) {
        parts.push('--ui-cell-size', cellSizeVal);
      }
      const unitsSelect = document.getElementById('units');
      const unitsVal = unitsSelect?.value;
      if (unitsVal) {
        parts.push('--ui-units', unitsVal);
      }
      if (currentDrawKind === 'rectangle' && Array.isArray(currentBboxArray)) {
        parts.push('--ui-bbox', currentBboxArray.join(','));
      } else if (currentDrawnGeoJSON) {
        parts.push('--ui-polygon', quoteSingle(JSON.stringify(currentDrawnGeoJSON)));
      }
      return parts.join(' ').replace(/\s+/g, ' ').trim();
    }

    function updateCliCommand() {
      if (!cliTextarea) return;
      cliTextarea.value = buildCliCommandString();
    }

    copyCliButton?.addEventListener('click', async () => {
      if (!cliTextarea) return;
      const text = cliTextarea.value;
      try {
        if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          cliTextarea.focus();
          cliTextarea.select();
          document.execCommand('copy');
          window.getSelection()?.removeAllRanges?.();
        }
        Toastify({
          text: 'CLIコマンドをコピーしました',
          duration: 3000,
          gravity: 'bottom',
          position: 'center',
          className: 'toast-info'
        }).showToast();
      } catch (err) {
        Toastify({
          text: `コピーに失敗しました: ${err?.message || err}`,
          duration: 4000,
          gravity: 'bottom',
          position: 'center',
          className: 'toast-error'
        }).showToast();
      }
    });

    updateCliCommand();

    socket.on('connect', () => {
      //console.log('Connected to server');
    });

    socket.on('disconnect', () => {
      //console.log('Disconnected from server');
    });

    document.getElementById('keywords')?.addEventListener('input', updateCliCommand);
    document.getElementById('cellSize')?.addEventListener('input', updateCliCommand);
    document.getElementById('units')?.addEventListener('change', updateCliCommand);

  let sessionId = null;
  let visualizers = {};
  let visualizerOptionSchemas = {};
  let results = {};
  let files = {};
  let layerControl = null;
  const hexProgress = {};

    function buildVisualizerOptionArgs() {
      const args = [];
      const visEntries = Object.entries(VIS_FORM_STATE.currentOptions || {});
      if (!visEntries.length) return args;

      const normalizeValue = (value) => {
        if (value == null || value === '') return null;
        if (typeof value === 'number') {
          if (!Number.isFinite(value)) return null;
          return { token: String(value), type: 'number' };
        }
        if (typeof value === 'boolean') {
          return { token: value ? 'true' : 'false', type: 'boolean' };
        }
        return { token: quoteSingle(String(value)), type: 'string' };
      };

      visEntries.forEach(([visId, fields]) => {
        if (!visId || typeof fields !== 'object') return;
        Object.keys(fields).sort().forEach((key) => {
          const normalized = normalizeValue(fields[key]);
          if (!normalized) return;
          const flag = `--v-${visId}-${key}`;
          args.push(flag, normalized.token);
        });
      });
      return args;
    }
    let welcomeReadyResolve;
    const welcomeReady = new Promise((resolve) => {
      welcomeReadyResolve = resolve;
    });
    socket.on("welcome", async (res) => {
      //console.log(`welcome ${res.sessionId} at ${new Date(res.time).toLocaleTimeString()}`);
      //console.log("VIS", res.visualizers);
      sessionId = res.sessionId;
      visualizerOptionSchemas = res.optionSchemas || {};
      visualizers = Object.fromEntries(await Promise.all(res.visualizers.map(async vis => {
        const m = await import(new URL(`./visualizer/${vis}/web.js`,
          import.meta.url).href);
        return [vis, m.entry ?? m.default ?? m[vis]];
      })));
      //console.log(visualizers);
      if (welcomeReadyResolve) {
        welcomeReadyResolve();
        welcomeReadyResolve = null;
      }
    });

    function generateLegend(legends) {
      return legends.reduce(
        (memo, legend) => {
          return memo + `<li><span class="legend_circle" style="border-color:${legend.stroke};background:${legend.fill};"></span><span class="legend_category">${legend.category}</spam></li>`
        },
        "");
    }
    const BottomLeftProgressBar = L.Control.extend({
      options: {
        position: 'bottomleft'
      },
      onAdd(map) {
        const div = L.DomUtil.create('div', 'map-bottom-left-progressbar');

        div.innerHTML = `
    <div class="panel-contents">
    <!-- 幅は親 .progress-wrap の width/max-width で制御。 -->
    <div id="progressCrawl" class="progress is-lg" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="32" aria-label="進捗" style="--value:32">
    <div class="progress__bar" aria-hidden="true"></div>
    <div class="progress__label" aria-hidden="true">32%</div>
    </div>
    </div>`;
        // コントロール内の操作が地図ドラッグに奪われないようにする
        L.DomEvent.disableClickPropagation(div);
        L.DomEvent.disableScrollPropagation(div);
        return div;
      }
    });
    const BottomLeftLegend = L.Control.extend({
      options: {
        position: 'bottomleft'
      },
      onAdd(map) {
        const div = L.DomUtil.create('div', 'map-bottom-left-legend');

        div.innerHTML = `
    <div class="panel-contents">
      <div id="map_legend">
      </div>
      <div class="center-x">
        <button id="download-json" class="dl-btn" title="Download JSON">
          <!-- インラインSVG（ダウンロードアイコン） -->
          <svg viewBox="0 0 640 640" width="16" height="16" aria-hidden="true">
           <!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M128.5 64C93.2 64 64.5 92.7 64.5 128L64.5 512C64.5 547.3 93.2 576 128.5 576L384.5 576C419.8 576 448.5 547.3 448.5 512L448.5 416L526.6 416L495.6 447C486.2 456.4 486.2 471.6 495.6 480.9C505 490.2 520.2 490.3 529.5 480.9L601.5 408.9C610.9 399.5 610.9 384.3 601.5 375L529.5 303C520.1 293.6 504.9 293.6 495.6 303C486.3 312.4 486.2 327.6 495.6 336.9L526.6 367.9L448.5 367.9L448.5 234.4C448.5 217.4 441.8 201.1 429.8 189.1L323.2 82.7C311.2 70.7 295 64 278 64L128.5 64zM390 240L296.5 240C283.2 240 272.5 229.3 272.5 216L272.5 122.5L390 240zM256.5 392C256.5 378.7 267.2 368 280.5 368L384.5 368L384.5 416L280.5 416C267.2 416 256.5 405.3 256.5 392z"/>
          </svg>
          <span class="label">エクスポート</span>
        </button>
      </div>
    </div>`;
        // コントロール内の操作が地図ドラッグに奪われないようにする
        L.DomEvent.disableClickPropagation(div);
        L.DomEvent.disableScrollPropagation(div);
        return div;
      }
    });
    socket.on('progress', (res) => {
      //res.currentHexはカテゴリごとのcrawled/totalを保持している
      const { crawled, total } = Object.values(res.currentHex ?? {}).reduce(
        (acc, cat) => (cat == null ? acc : {
          crawled: acc.crawled + (cat.crawled ?? 0),
          total: acc.total + (cat.total ?? 0)
        }),
        { crawled: 0, total: 0 }
      );
      const safeTotal = Math.max(1, total);
      const normalized = total === 0 ? 1 : Math.min(1, crawled / safeTotal);
      hexProgress[res.hexId] = {
        crawled,
        total: safeTotal,
        normalized
      };

      const aggregated = Object.values(hexProgress).reduce(
        (acc, hex) => ({
          crawled: acc.crawled + (hex?.crawled ?? 0),
          total: acc.total + (hex?.total ?? 0)
        }),
        { crawled: 0, total: 0 }
      );
      const aggSafeTotal = Math.max(1, aggregated.total);
      const overallNormalized = aggregated.total === 0 ? 1 : Math.min(1, aggregated.crawled / aggSafeTotal);
      const percent = Math.round(overallNormalized * 100000) / 1000;
      setProgress(document.getElementById("progressCrawl"), percent);
      //ここでHexのプログレスグラデーションレイヤのOpacity調整
      highlightHexById(res.hexId, 1 - normalized, "#263238");
    });

    function isPlainObject(a) {
      if (a === null || typeof a !== 'object') return false; // 原始値/関数など除外
      const proto = Object.getPrototypeOf(a);
      return proto === Object.prototype || proto === null; // {} / Object.create(null)
    }
    socket.on("toast", (arg) => {
      const option = {
        text: "",
        duration: arg.close ? -1 : 5000,
        close: false,
        gravity: 'bottom',
        position: 'center',
        className: "toast-" + arg.class,
        ...arg
      };
      Toastify(option).showToast();
      //https://apvarun.github.io/toastify-js/#
    });
    socket.on("result-file", async(arg, callback) => {
      try {
        const file_path = '/out/result.' + arg.resultId + '.json';
        latestFile = file_path;
        files[arg.resultId] = file_path;
        console.log("file path",file_path);
        results[arg.resultId] = await fetchJsonObject(file_path);
        console.log('結果ファイル取得完了');
      } catch (e) {
        console.error('結果ファイル取得失敗:', e);
      }
      //console.log("ARK");
      callback({
        pong: Date.now(),
        ok: true
      }); // only one argument is expected
    });
    socket.on("result-chunk", (arg, callback) => {
      if (arg.progress) {
        setProgress(document.getElementById("progressCrawl"), Math.round((arg.progress.current / arg.progress.total) * 100000) / 1000);
      }
      results[arg.resultId] ??= {};
      if (arg.kind === "primitive" || arg.kind === "null") {
        //'number' | 'string' | 'boolean' | 'bigint' | 'symbol' | 'undefined'
        //console.log(arg.path,arg.value);
        switch (arg.type) {
          case 'number':
            setAt(results[arg.resultId], arg.path, Number(arg.value));
            break;
          case 'boolean':
            setAt(results[arg.resultId], arg.path, arg.value);
          case 'string':
            setAt(results[arg.resultId], arg.path, String(arg.value));
            break;
          case 'bigint':
            setAt(results[arg.resultId], arg.path, BigInt(arg.value));
            break;
          case 'symbol':
            setAt(results[arg.resultId], arg.path, Symbol(arg.value));
            break;
          default:
            setAt(results[arg.resultId], arg.path, null);
        }
      } else if (arg.kind === "object") {
        setAt(results[arg.resultId], arg.path, {});
      } else if (arg.kind === "array") {
        setAt(results[arg.resultId], arg.path, []);
      }
      //console.log("ARK");
      callback({
        pong: Date.now(),
        ok: true
      }); // only one argument is expected
    });

    let latestResult = null;
    let latestFile = null;
    const overlays = {};
    const resultExtras = {};

    async function visualizeBundle(bundle, { sourceLabel = 'server' } = {}) {
      await welcomeReady;
      if (!bundle || typeof bundle !== 'object') {
        Toastify({
          text: '結果データを読み込めませんでした',
          duration: 4000,
          gravity: 'bottom',
          position: 'center',
          className: 'toast-error'
        }).showToast();
        return false;
      }

      clearHexHighlight();
      const geoJson = bundle.geoJson ?? {};
      const palette = bundle.palette ?? {};
      const visOptionsFromServer = bundle.visOptions ?? {};
      const rawMeta = bundle.raw ?? null;

      VIS_FORM_STATE.defaultOptions = JSON.parse(JSON.stringify(visOptionsFromServer || {}));
      VIS_FORM_STATE.currentOptions = JSON.parse(JSON.stringify(visOptionsFromServer || {}));
      VIS_FORM_STATE.rawSource = rawMeta || null;
      VIS_FORM_STATE.visualizerOrder = bundle.visualizers || Object.keys(geoJson) || [];
      updateVisOptionPanel();
      updateCliCommand();

      renderStatsPanel(bundle.context?.stats ?? null);
      bundle.extra = {
        ...(bundle.extra ?? {}),
        ...resultExtras
      };
      latestResult = bundle;
      latestFile = null;

      const bundleHexGrid = bundle.context?.hexGrid ?? bundle.extra?.hex ?? null;
      let bundleTriangles = bundle.context?.triangles ?? null;
      if (!bundleTriangles) {
        const extraTriangles = bundle.extra?.triangles;
        if (Array.isArray(extraTriangles)) {
          bundleTriangles = extraTriangles.find((entry) => entry?.type === 'FeatureCollection') ?? null;
        } else if (extraTriangles?.type === 'FeatureCollection') {
          bundleTriangles = extraTriangles;
        }
      }
      if (bundleHexGrid || bundleTriangles) {
        refreshGridLayers(bundleHexGrid ?? null, bundleTriangles ?? null, { addToMap: false });
      }

      if (layerControl) {
        map.removeControl(layerControl);
        layerControl = null;
      }

      Object.keys(overlays).forEach((key) => {
        const layer = overlays[key];
        if (!layer) return;
        if (typeof layer.remove === 'function') {
          try { layer.remove(); } catch (err) { console.warn('failed to remove layer', err); }
        } else if (typeof layer.removeFrom === 'function') {
          try { layer.removeFrom(map); } catch (err) { console.warn('failed to remove layer', err); }
        } else if (layer instanceof L.Layer) {
          try { map.removeLayer(layer); } catch (err) { console.warn('failed to remove layer', err); }
        }
        delete overlays[key];
      });

      for (const vis of Object.keys(visualizers)) {
        const handler = visualizers[vis];
        if (typeof handler !== 'function') continue;
        let layers = null;
        try {
          layers = await handler(map, geoJson[vis], {
            palette,
            visOptions: visOptionsFromServer[vis]
          });
        } catch (err) {
          console.error(`[visualizer:${vis}] failed`, err);
          continue;
        }
        if (!layers) continue;
        if (isPlainObject(layers) && !layers.type) {
          for (const name in layers) {
            overlays[`[${vis}] ${name}`] = layers[name];
          }
        } else {
          overlays[`[${vis}]`] = layers;
        }
      }

      if (myProgress) {
        map.removeControl(myProgress);
        myProgress = null;
      }
      if (myLegend) {
        map.removeControl(myLegend);
        myLegend = null;
      }
      document.getElementById('map_legend')?.replaceChildren();
      myLegend = new BottomLeftLegend().addTo(map);
      const ul = document.createElement('div');
      ul.className = 'legend_ul';
      const paletteEntries = Object.entries(palette).map(([category, colors]) => ({
        category,
        fill: colors?.color ?? '#ffffff',
        stroke: colors?.darken ?? colors?.color ?? '#ffffff'
      }));
      ul.innerHTML = generateLegend(paletteEntries);
      document.getElementById('map_legend')?.appendChild(ul);

      const overlayOptions = { ...overlays };
      if (drawnItems && drawnItems.getLayers().length > 0) {
        overlayOptions['Boundary'] = drawnItems;
      }
      if (hexLayer) {
        overlayOptions['Hex Grid'] = hexLayer;
      }
      if (triLayer) {
        overlayOptions['Tri Grid'] = triLayer;
      }

      if (layerControl) {
        map.removeControl(layerControl);
      }
      layerControl = L.control.layers([baseLayer], overlayOptions, {
        position: 'topleft'
      });
      layerControl.addTo(map);

      const downloadBtn = document.getElementById('download-json');
      if (downloadBtn && downloadBtn.dataset.bound !== '1') {
        downloadBtn.dataset.bound = '1';
        downloadBtn.addEventListener('click', async () => {
          const stamp = new Date().toISOString().replace(/[:.]/g, '-');
          if (latestFile === null) {
            if (latestResult) {
              downloadJSON(`splatone-${stamp}.json`, latestResult);
            }
          } else {
            await downloadJSONFile(`splatone-${stamp}.json`, latestFile);
          }
        });
      }

      Toastify({
        text: `結果を読み込みました (${sourceLabel})`,
        duration: 2600,
        gravity: 'bottom',
        position: 'center',
        className: 'toast-success'
      }).showToast();
      return true;
    }
    socket.on('result', async (res, callback) => {
      let bundle = res.bundle ?? null;
      if (!bundle) {
        bundle = results[res.resultId];
      } else {
        results[res.resultId] = bundle;
      }
      if (!bundle) {
        console.warn('[result] bundle not available yet');
        callback({ pong: Date.now(), ok: false });
        return;
      }
      const success = await visualizeBundle(bundle, { sourceLabel: 'server' });
      callback({
        pong: Date.now(),
        ok: Boolean(success)
      });
    });

    // 地図
    const map = L.map('map', {
      preferCanvas: true,
      zoomControl: true
    }).setView([initialLat, initialLon], initialZoom);

    const persistMapView = debounce(() => {
      const center = map.getCenter();
      writeMapViewCookie({
        lat: Number(center.lat.toFixed(6)),
        lon: Number(center.lng.toFixed(6)),
        zoom: map.getZoom()
      });
    }, 500);

    map.on('moveend', persistMapView);
    map.on('zoomend', persistMapView);
    const baseLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    /*
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    */
    // Drawn items
    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    // Draw control（矩形・ポリゴンのみ）
    let drawControl = null;
    if (!browseMode) {
      drawControl = new L.Control.Draw({
        position: 'topleft',
        draw: {
          polygon: {
            allowIntersection: false,
            showArea: true,
            metric: true,
          },
          polyline: false,
          marker: false,
          circle: false,
          circlemarker: false,
          rectangle: {
            shapeOptions: {
              weight: 1,
              fillOpacity: 0
            }
          }
        },
      });
      map.addControl(drawControl);
    }

    //印刷
    L.easyPrint({
      title: 'マップの画像化とダウンロード',
      position: 'bottomright',
      sizeModes: ['A4Landscape'],
      exportOnly: true,
      filename: 'splatone_export'
    }).addTo(map);

    // レイヤ参照
    let hexLayer = null;
    let triLayer = null;
    let myStartBtn = null;
    let myLegend = null;
    let myProgress = null;
    let hexLayerIndex = {}; // hexId -> layer
    let triLayerIndex = {}; // triangleId -> layer

    // Util: Bounds → "minLon,minLat,maxLon,maxLat"
    function boundsToBbox(bounds) {
      return [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()].join(',');
    }

    // ハイライト制御
    function clearHexHighlight() {
      Object.values(hexLayerIndex).forEach(layer => {
        layer.setStyle({
          weight: 2,
          opacity: 0.5,
          fillOpacity: 0.1,
          color: "#37474F",
          fillColor: "#546E7A",
        });
      });
    }

    function highlightHexById(hexId, fillOpacity = 0.7, fillColor = "#3949AB") {
      const layer = hexLayerIndex[hexId];
      if (layer) {
        layer.setStyle({
          weight: 2,
          opacity: 1,
          fillOpacity: fillOpacity,
          color: "#37474F",
          fillColor: fillColor,
        });
        if (layer.bringToFront) layer.bringToFront();
      }
    }

    function clearTriHighlight() {
      Object.values(triLayerIndex).forEach(layer => {
        layer.setStyle({
          weight: 1,
          opacity: 0.8,
          fillOpacity: 0,
          fillColor: "#EC407A",
          color: "#F50057",
          dashArray: "10 20",
          dashOffset: 10,
        });
      });
    }

    function highlightTriangle(triId, style = {
      weight: 1,
      opacity: 1,
      fillOpacity: 0.5,
      fillColor: "#EC407A",
      color: "#F50057",
      dashArray: "15,30",
      dashOffset: 0,
    }) {
      const layer = triLayerIndex[triId];
      if (layer) {
        layer.setStyle(style);
        if (layer.bringToFront) layer.bringToFront();
      }
    }

    function refreshGridLayers(hexFC = null, trianglesFC = null, { addToMap = true } = {}) {
      const hexWasVisible = hexLayer ? map.hasLayer(hexLayer) : false;
      const triWasVisible = triLayer ? map.hasLayer(triLayer) : false;

      if (hexLayer) {
        map.removeLayer(hexLayer);
        hexLayer = null;
      }
      if (triLayer) {
        map.removeLayer(triLayer);
        triLayer = null;
      }
      hexLayerIndex = {};
      triLayerIndex = {};

      if (hexFC) {
        const nextHexLayer = L.geoJSON(hexFC, {
          style: {
            weight: 2,
            opacity: 0.5,
            fillOpacity: 0.1,
            color: "#37474F",
            fillColor: "#546E7A",
          },
          onEachFeature: (feature, layer) => {
            const hid = feature.properties?.hexId;
            if (hid != null) hexLayerIndex[hid] = layer;
            const triIds = feature.properties?.triIds?.length ? feature.properties.triIds.join(', ') : 'N/A';
            layer.bindPopup(`Hex ID: ${hid}<br>Triangles: ${triIds}`);
          }
        });
        hexLayer = nextHexLayer;
        if (addToMap || hexWasVisible) {
          nextHexLayer.addTo(map);
        }
      }

      if (trianglesFC) {
        const nextTriLayer = L.geoJSON(trianglesFC, {
          style: {
            weight: 1,
            opacity: 0.8,
            fillOpacity: 0,
            fillColor: "#EC407A",
            color: "#F50057",
            dashArray: "15,30",
            dashOffset: 0,
          },
          onEachFeature: (feature, layer) => {
            const pid = feature.properties?.parentHexId ?? 'N/A';
            const tid = feature.properties?.triangleId ?? 'N/A';
            const cross = feature.properties?.crossNeighbors ?? [];
            const neighborHexIds = feature.properties?.neighborHexIds ?? [];

            triLayerIndex[tid] = layer;

            layer.bindPopup(
              `Triangle: ${tid}<br>` +
              `Parent Hex: ${pid}<br>` +
              `Cross neighbors: ${cross.length ? cross.join(', ') : 'None'}<br>` +
              `Neighbor Hexes: ${neighborHexIds.length ? neighborHexIds.join(', ') : 'None'}`
            );

            layer.on('click', () => {
              clearHexHighlight();
              clearTriHighlight();
              highlightHexById(pid);
              highlightTriangle(tid, {
                weight: 3,
                opacity: 1,
                fillOpacity: 0.30
              });

              cross.forEach(cid => {
                highlightTriangle(cid, {
                  weight: 2,
                  opacity: 1,
                  fillOpacity: 0.25
                });
                const neighborLayer = triLayerIndex[cid];
                if (neighborLayer) {
                  const pHex = neighborLayer.feature?.properties?.parentHexId;
                  if (pHex != null) highlightHexById(pHex);
                }
              });
            });

            layer.on('mouseout', () => {
              clearTriHighlight();
            });
          }
        });
        triLayer = nextTriLayer;
        if (addToMap || triWasVisible) {
          nextTriLayer.addTo(map);
        }
      }
    }

    // Hex / Triangles を描画
    function renderLayers(hexFC, trianglesFC) {
      document.getElementById('map_legend')?.replaceChildren();
      if (myLegend) map.removeControl(myLegend);
      if (myStartBtn) map.removeControl(myStartBtn);

      refreshGridLayers(hexFC, trianglesFC, { addToMap: true });

      if (!browseMode) {
        const BottomLeftPanel = L.Control.extend({
          options: {
            position: 'bottomleft'
          },
          onAdd(map) {
            const div = L.DomUtil.create('div', 'map-bottom-left-control');
            div.innerHTML = `
      <div class="panel-contents">
        <button class="btn"id="doSomething">Start Crawling!</button>
      </div>`;
            L.DomEvent.disableClickPropagation(div);
            L.DomEvent.disableScrollPropagation(div);

            const btn = div.querySelector('#doSomething');
            btn.addEventListener('click', (ev) => {
              ev.preventDefault();
              ev.stopPropagation();
              if (myStartBtn) map.removeControl(myStartBtn);
              myProgress = new BottomLeftProgressBar().addTo(map);
              socket.emit("crawling", {
                sessionId: sessionId,
              });
            }, {
              once: true
            });

            return div;
          }
        });
        myStartBtn = new BottomLeftPanel().addTo(map);
      }

      const layers = [hexLayer, triLayer].filter(Boolean);
      if (layers.length > 0) {
        const bounds = L.featureGroup(layers).getBounds();
        if (bounds.isValid()) map.fitBounds(bounds, {
          padding: [20, 20]
        });
      }
    }

    // API呼び出し
    async function loadHexgridByBounds(bounds, drawn = null, shapeKind = null) {
      if (browseMode) {
        return;
      }
      currentBboxArray = [
        Number(bounds.getWest().toFixed(6)),
        Number(bounds.getSouth().toFixed(6)),
        Number(bounds.getEast().toFixed(6)),
        Number(bounds.getNorth().toFixed(6)),
      ];
  currentDrawnGeoJSON = drawn || null;
  currentDrawKind = drawn ? (shapeKind || 'polygon') : null;
      const bbox = boundsToBbox(bounds);
      document.getElementById('bboxLabel').textContent = `BBOX: ${bbox}`;
      updateCliCommand();

      const cellSize = document.getElementById('cellSize').value.trim();
      const units = document.getElementById('units').value.trim();
      const keywords = document.getElementById('keywords').value.trim();
      resultExtras.keywords = keywords;
      socket.once("hexgrid", (res) => {
        if (res.sessionId) sessionId = res.sessionId;
        //console.log(`hexgrid received (${res.hex.features.length} hexes, ${res.triangles.features.length} triangles)`);
        Object.keys(hexProgress).forEach((key) => delete hexProgress[key]);
        const hex = res.hex;
        const triangles = res.triangles;
        resultExtras.hex = hex;
        resultExtras.triangles = [triangles];
        renderStatsPanel(null);
        renderLayers(hex, triangles);
      });
      socket.emit("target", {
        sessionId: sessionId,
        query: {
          bbox: bbox,
          drawn: drawn,
          cellSize: cellSize,
          units: units,
          tags: keywords
        }
      });
    }

    if (!browseMode) {
      map.on(L.Draw.Event.CREATED, async (e) => {
        drawnItems.clearLayers();
        const layer = e.layer;
        layer.__splatoneShape = e.layerType === 'rectangle' ? 'rectangle' : 'polygon';
        drawnItems.addLayer(layer);
        try {
          await loadHexgridByBounds(layer.getBounds(), layer.toGeoJSON(), layer.__splatoneShape);
        } catch (err) {
          alert(err.message);
        }
      });

      map.on(L.Draw.Event.EDITSTOP, async () => {
        const layers = drawnItems.getLayers();
        if (layers.length === 1) {
          try {
            const layer = layers[0];
            const shapeKind = layer.__splatoneShape || (layer instanceof L.Rectangle ? 'rectangle' : 'polygon');
            await loadHexgridByBounds(layer.getBounds(), layer.toGeoJSON(), shapeKind);
          } catch (err) {
            alert(err.message);
          }
        }
      });

      map.on(L.Draw.Event.DELETED, () => {
        drawnItems.clearLayers();
        if (hexLayer) {
          map.removeLayer(hexLayer);
          hexLayer = null;
        }
        if (triLayer) {
          map.removeLayer(triLayer);
          triLayer = null;
        }
        if (myStartBtn) {
          map.removeControl(myStartBtn);
          myStartBtn = null;
        }
        if (myLegend) {
          document.getElementById('map_legend')?.replaceChildren();
          map.removeControl(myLegend);
          myLegend = null;
        }
        document.getElementById('bboxLabel').textContent = '';
        currentDrawnGeoJSON = null;
        currentDrawKind = null;
        currentBboxArray = null;
        updateCliCommand();
      });
    }

    if (browseMode) {
      initDropImport();
    }

    function initDropImport() {
      const overlay = document.getElementById('dropOverlay');
      if (!overlay) return;
      let dragDepth = 0;
      const showOverlay = () => {
        overlay.hidden = false;
        overlay.classList.add('visible');
      };
      const hideOverlay = () => {
        overlay.classList.remove('visible');
        overlay.hidden = true;
      };
      const hasFiles = (event) => Array.from(event.dataTransfer?.types ?? []).includes('Files');

      window.addEventListener('dragenter', (event) => {
        if (!hasFiles(event)) return;
        dragDepth += 1;
        showOverlay();
        event.preventDefault();
      });
      window.addEventListener('dragover', (event) => {
        if (!hasFiles(event)) return;
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy';
      });
      window.addEventListener('dragleave', (event) => {
        if (dragDepth > 0) {
          dragDepth -= 1;
        }
        if (dragDepth <= 0) {
          dragDepth = 0;
          hideOverlay();
        }
      });
      window.addEventListener('drop', async (event) => {
        if (!hasFiles(event)) return;
        event.preventDefault();
        dragDepth = 0;
        hideOverlay();
        const file = event.dataTransfer?.files?.[0] ?? null;
        if (file) {
          await importResultFile(file);
        }
      });
    }

    document.getElementById('applyVisOptions')?.addEventListener('click', () => {
      applyVisOptionChanges();
    });
    document.getElementById('resetVisOptions')?.addEventListener('click', () => {
      resetVisOptions();
    });

    async function importResultFile(file) {
      try {
        const text = await file.text();
        let parsed;
        try {
          parsed = JSON.parse(text);
        } catch (err) {
          throw new Error('JSONとして解析できませんでした');
        }
        if (parsed && typeof parsed === 'object' && parsed.crawler && parsed.target) {
          const response = await postJson('/api/revisualize', { rawPayload: parsed });
          if (!response?.ok || !response.bundle) {
            throw new Error(response?.error || '再可視化エンドポイントがエラーを返しました');
          }
          await visualizeBundle(response.bundle, { sourceLabel: file.name || 'raw file' });
          return;
        }
        const bundle = parsed?.bundle ?? parsed;
        if (!bundle || typeof bundle !== 'object' || !bundle.geoJson) {
          throw new Error('結果バンドルではありません');
        }
        await visualizeBundle(bundle, { sourceLabel: file.name || 'file' });
      } catch (err) {
        Toastify({
          text: `読み込みに失敗しました: ${err?.message || err}`,
          duration: 4000,
          gravity: 'bottom',
          position: 'center',
          className: 'toast-error'
        }).showToast();
      }
    }

    function resetVisOptions() {
      VIS_FORM_STATE.currentOptions = JSON.parse(JSON.stringify(VIS_FORM_STATE.defaultOptions || {}));
      updateVisOptionFormValues();
      updateCliCommand();
    }

    function updateVisOptionFormValues() {
      const formRows = document.querySelectorAll('[data-vis-option="row"]');
      formRows.forEach((row) => {
        const vis = row.dataset.visId;
        const field = row.dataset.fieldKey;
        const input = row.querySelector('input, select');
        if (!input || !vis || !field) return;
        const value = VIS_FORM_STATE.currentOptions?.[vis]?.[field];
        if (value == null || value === '') {
          input.value = '';
        } else if (input.type === 'number') {
          input.value = Number(value);
        } else if (input.type === 'checkbox') {
          input.checked = Boolean(value);
        } else {
          input.value = value;
        }
      });
    }

    function updateVisOptionPanel() {
      const section = document.getElementById('rawReviewSection');
      const container = document.getElementById('visOptionForms');
      const hint = document.getElementById('rawReviewHint');
      const applyBtn = document.getElementById('applyVisOptions');
      const resetBtn = document.getElementById('resetVisOptions');
      const meta = document.getElementById('rawMetaInfo');
      if (!section || !container || !applyBtn || !resetBtn) return;

      const visOrder = Array.isArray(VIS_FORM_STATE.visualizerOrder) ? VIS_FORM_STATE.visualizerOrder : [];
      if (!visOrder.length || !VIS_FORM_STATE.rawSource) {
        section.hidden = true;
        container.innerHTML = '';
        applyBtn.disabled = true;
        resetBtn.disabled = true;
        hint.hidden = false;
        meta.textContent = '';
        return;
      }

      section.hidden = false;
      hint.hidden = true;
      container.innerHTML = '';
      applyBtn.disabled = false;
      resetBtn.disabled = false;
      const metaParts = [];
      if (VIS_FORM_STATE.rawSource?.sessionId) metaParts.push(`session ${VIS_FORM_STATE.rawSource.sessionId}`);
      if (VIS_FORM_STATE.rawSource?.fileName) metaParts.push(`file ${VIS_FORM_STATE.rawSource.fileName}`);
      if (VIS_FORM_STATE.rawSource?.type) metaParts.push(`source ${VIS_FORM_STATE.rawSource.type}`);
      meta.textContent = metaParts.join(' / ');

      visOrder.forEach((visName) => {
        const schema = visualizerOptionSchemas?.[visName];
        if (!schema || !Array.isArray(schema.fields) || !schema.fields.length) return;
        const card = document.createElement('div');
        card.className = 'vis-option-card';
        const title = document.createElement('h4');
        title.textContent = schema.label || visName;
        card.appendChild(title);
        const grid = document.createElement('div');
        grid.className = 'vis-option-grid';
        schema.fields.forEach((field) => {
          const row = document.createElement('label');
          row.dataset.visOption = 'row';
          row.dataset.visId = visName;
          row.dataset.fieldKey = field.key;
          const span = document.createElement('span');
          span.textContent = field.label || field.key;
          row.appendChild(span);
          let input;
          if (field.type === 'select' && Array.isArray(field.options)) {
            input = document.createElement('select');
            field.options.forEach((opt) => {
              const option = document.createElement('option');
              option.value = opt;
              option.textContent = opt;
              input.appendChild(option);
            });
          } else if (field.type === 'boolean') {
            input = document.createElement('input');
            input.type = 'checkbox';
          } else {
            input = document.createElement('input');
            input.type = field.type === 'number' ? 'number' : 'text';
            if (field.placeholder) input.placeholder = field.placeholder;
            if (field.step != null) input.step = field.step;
            if (field.min != null) input.min = field.min;
            if (field.max != null) input.max = field.max;
          }
          input.dataset.visId = visName;
          input.dataset.fieldKey = field.key;
          input.addEventListener('input', handleVisOptionInput);
          if (input.type === 'checkbox') {
            input.addEventListener('change', handleVisOptionInput);
          }
          row.appendChild(input);
          grid.appendChild(row);
        });
        card.appendChild(grid);
        container.appendChild(card);
      });

      updateVisOptionFormValues();
    }

    function handleVisOptionInput(event) {
      const input = event.currentTarget;
      const vis = input?.dataset?.visId;
      const fieldKey = input?.dataset?.fieldKey;
      if (!vis || !fieldKey) return;
      VIS_FORM_STATE.currentOptions[vis] ??= {};
      let value = input.value;
      if (input.type === 'number') {
        const num = Number(value);
        value = Number.isFinite(num) ? num : undefined;
      } else if (input.type === 'checkbox') {
        value = Boolean(input.checked);
      }
      if (value === '' || value === undefined) {
        delete VIS_FORM_STATE.currentOptions[vis][fieldKey];
      } else {
        VIS_FORM_STATE.currentOptions[vis][fieldKey] = value;
      }
      updateCliCommand();
    }

    async function applyVisOptionChanges() {
      const applyBtn = document.getElementById('applyVisOptions');
      if (!applyBtn) return;
      applyBtn.disabled = true;
      try {
        if (!VIS_FORM_STATE.rawSource) {
          throw new Error('raw data is not available');
        }
        const payload = {
          sessionId: VIS_FORM_STATE.rawSource.sessionId,
          rawFile: VIS_FORM_STATE.rawSource.fileName,
          visualizers: VIS_FORM_STATE.visualizerOrder,
          visOptions: VIS_FORM_STATE.currentOptions
        };
        const response = await postJson('/api/revisualize', payload);
        if (!response?.ok) {
          throw new Error(response?.error || 'failed');
        }
        if (response.bundle) {
          await visualizeBundle(response.bundle, { sourceLabel: '再可視化' });
        }
      } catch (err) {
        Toastify({
          text: `再可視化に失敗しました: ${err?.message || err}`,
          duration: 4000,
          gravity: 'bottom',
          position: 'center',
          className: 'toast-error'
        }).showToast();
      } finally {
        applyBtn.disabled = false;
      }
    }

    // ======= ハンバーガー / パネル制御 =======
    const hamburger = document.getElementById('hamburger');
    const sidepanel = document.getElementById('sidepanel');
    const panelClose = document.getElementById('panelClose');
    const panelOverlay = document.getElementById('panelOverlay');

    function openPanel() {
      sidepanel.classList.add('open');
      hamburger.setAttribute('aria-expanded', 'true');
      sidepanel.setAttribute('aria-hidden', 'false');
      panelOverlay.hidden = false;
      // 画面幅が狭い時に、Leafletのツールと干渉しないようパネルを最前面に
    }

    function closePanel() {
      sidepanel.classList.remove('open');
      hamburger.setAttribute('aria-expanded', 'false');
      sidepanel.setAttribute('aria-hidden', 'true');
      panelOverlay.hidden = true;
    }

    hamburger.addEventListener('click', () => {
      if (sidepanel.classList.contains('open')) closePanel();
      else openPanel();
    });
    panelClose.addEventListener('click', closePanel);
    panelOverlay.addEventListener('click', closePanel);
    // ESCで閉じる
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closePanel();
    });

    async function applyDefaultGeometry() {
      if (!defaultGeometry || (!defaultGeometry.polygon && !Array.isArray(defaultGeometry.bbox))) {
        return;
      }

      const ensureDraw = async (layer) => {
        await welcomeReady;
        drawnItems.clearLayers();
        layer.__splatoneShape = layer.__splatoneShape || (layer instanceof L.Rectangle ? 'rectangle' : 'polygon');
        drawnItems.addLayer(layer);
        await loadHexgridByBounds(layer.getBounds(), layer.toGeoJSON(), layer.__splatoneShape);
      };

      if (defaultGeometry.polygon && typeof defaultGeometry.polygon === 'object') {
        const geoLayer = L.geoJSON(defaultGeometry.polygon);
        const layers = geoLayer.getLayers();
        if (layers.length > 0) {
          const layer = layers[0];
          if (layer.getBounds().isValid()) {
            map.fitBounds(layer.getBounds(), { padding: [20, 20] });
          }
          layer.__splatoneShape = 'polygon';
          await ensureDraw(layer);
          return;
        }
      }

      if (Array.isArray(defaultGeometry.bbox) && defaultGeometry.bbox.length === 4) {
        const [minLon, minLat, maxLon, maxLat] = defaultGeometry.bbox;
        if ([minLon, minLat, maxLon, maxLat].every(val => Number.isFinite(Number(val)))) {
          const bounds = L.latLngBounds([
            [minLat, minLon],
            [maxLat, maxLon]
          ]);
          const rectangle = L.rectangle(bounds, { weight: 1, fillOpacity: 0 });
          rectangle.__splatoneShape = 'rectangle';
          if (bounds.isValid()) {
            map.fitBounds(bounds, { padding: [20, 20] });
          }
          await ensureDraw(rectangle);
        }
      }
    }

    if (!browseMode && (defaultGeometry?.polygon || Array.isArray(defaultGeometry?.bbox))) {
      applyDefaultGeometry().catch((err) => console.error('Failed to apply default geometry', err));
    }
  </script>
</body>

</html>